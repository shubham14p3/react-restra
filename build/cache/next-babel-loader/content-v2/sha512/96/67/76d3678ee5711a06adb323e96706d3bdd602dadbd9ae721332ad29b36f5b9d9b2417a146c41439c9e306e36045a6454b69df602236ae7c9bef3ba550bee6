{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React, { memo, useCallback, useLayoutEffect, useRef, useState } from \"react\";\nimport usePrevious from '../../../../../utils/hooks/usePrevious';\n\nfunction SingleOTPInputComponent(props) {\n  const {\n    focus,\n    autoFocus\n  } = props,\n        rest = _objectWithoutProperties(props, [\"focus\", \"autoFocus\"]);\n\n  const inputRef = useRef(null);\n  const prevFocus = usePrevious(!!focus);\n  useLayoutEffect(() => {\n    if (inputRef.current) {\n      if (focus && autoFocus) {\n        inputRef.current.focus();\n      }\n\n      if (focus && autoFocus && focus !== prevFocus) {\n        inputRef.current.focus();\n        inputRef.current.select();\n      }\n    }\n  }, [autoFocus, focus, prevFocus]);\n  return /*#__PURE__*/_jsx(\"input\", _objectSpread({\n    ref: inputRef\n  }, rest));\n}\n\nconst SingleInput = /*#__PURE__*/React.memo(SingleOTPInputComponent);\nexport function OTPInputComponent(props) {\n  const {\n    length,\n    isNumberInput,\n    autoFocus,\n    disabled,\n    onChangeOTP,\n    inputClassName,\n    inputStyle\n  } = props,\n        rest = _objectWithoutProperties(props, [\"length\", \"isNumberInput\", \"autoFocus\", \"disabled\", \"onChangeOTP\", \"inputClassName\", \"inputStyle\"]);\n\n  const {\n    0: activeInput,\n    1: setActiveInput\n  } = useState(0);\n  const {\n    0: otpValues,\n    1: setOTPValues\n  } = useState(Array(length).fill(\"\")); // Helper to return OTP from inputs\n\n  const handleOtpChange = useCallback(otp => {\n    const otpValue = otp.join(\"\");\n    onChangeOTP(otpValue);\n  }, [onChangeOTP]); // Helper to return value with the right type: 'text' or 'number'\n\n  const getRightValue = useCallback(str => {\n    let changedValue = str;\n\n    if (!isNumberInput) {\n      return changedValue;\n    }\n\n    return !changedValue || /\\d/.test(changedValue) ? changedValue : \"\";\n  }, [isNumberInput]); // Change OTP value at focussing input\n\n  const changeCodeAtFocus = useCallback(str => {\n    const updatedOTPValues = [...otpValues];\n    updatedOTPValues[activeInput] = str[0] || \"\";\n    setOTPValues(updatedOTPValues);\n    handleOtpChange(updatedOTPValues);\n  }, [activeInput, handleOtpChange, otpValues]); // Focus `inputIndex` input\n\n  const focusInput = useCallback(inputIndex => {\n    const selectedIndex = Math.max(Math.min(length - 1, inputIndex), 0);\n    setActiveInput(selectedIndex);\n  }, [length]);\n  const focusPrevInput = useCallback(() => {\n    focusInput(activeInput - 1);\n  }, [activeInput, focusInput]);\n  const focusNextInput = useCallback(() => {\n    focusInput(activeInput + 1);\n  }, [activeInput, focusInput]); // Handle onFocus input\n\n  const handleOnFocus = useCallback(index => () => {\n    focusInput(index);\n  }, [focusInput]); // Handle onChange value for each input\n\n  const handleOnChange = useCallback(e => {\n    const val = getRightValue(e.currentTarget.value);\n\n    if (!val) {\n      e.preventDefault();\n      return;\n    }\n\n    changeCodeAtFocus(val);\n    focusNextInput();\n  }, [changeCodeAtFocus, focusNextInput, getRightValue]); // Hanlde onBlur input\n\n  const onBlur = useCallback(() => {\n    setActiveInput(-1);\n  }, []); // Handle onKeyDown input\n\n  const handleOnKeyDown = useCallback(e => {\n    switch (e.key) {\n      case \"Backspace\":\n      case \"Delete\":\n        {\n          e.preventDefault();\n\n          if (otpValues[activeInput]) {\n            changeCodeAtFocus(\"\");\n          } else {\n            focusPrevInput();\n          }\n\n          break;\n        }\n\n      case \"ArrowLeft\":\n        {\n          e.preventDefault();\n          focusPrevInput();\n          break;\n        }\n\n      case \"ArrowRight\":\n        {\n          e.preventDefault();\n          focusNextInput();\n          break;\n        }\n\n      case \" \":\n        {\n          e.preventDefault();\n          break;\n        }\n\n      default:\n        break;\n    }\n  }, [activeInput, changeCodeAtFocus, focusNextInput, focusPrevInput, otpValues]);\n  const handleOnPaste = useCallback(e => {\n    e.preventDefault();\n    const pastedData = e.clipboardData.getData(\"text/plain\").trim().slice(0, length - activeInput).split(\"\");\n\n    if (pastedData) {\n      let nextFocusIndex = 0;\n      const updatedOTPValues = [...otpValues];\n      updatedOTPValues.forEach((val, index) => {\n        if (index >= activeInput) {\n          const changedValue = getRightValue(pastedData.shift() || val);\n\n          if (changedValue) {\n            updatedOTPValues[index] = changedValue;\n            nextFocusIndex = index;\n          }\n        }\n      });\n      setOTPValues(updatedOTPValues);\n      setActiveInput(Math.min(nextFocusIndex + 1, length - 1));\n    }\n  }, [activeInput, getRightValue, length, otpValues]);\n  return /*#__PURE__*/_jsx(\"div\", _objectSpread(_objectSpread({}, rest), {}, {\n    children: Array(length).fill(\"\").map((_, index) => /*#__PURE__*/_jsx(SingleInput, {\n      focus: activeInput === index,\n      autocomplete: \"new-password\",\n      value: otpValues && otpValues[index],\n      autoFocus: autoFocus,\n      onFocus: handleOnFocus(index),\n      onChange: handleOnChange,\n      onKeyDown: handleOnKeyDown,\n      onBlur: onBlur,\n      onPaste: handleOnPaste,\n      style: inputStyle,\n      className: inputClassName,\n      disabled: disabled\n    }, `SingleInput-${index}`))\n  }));\n}\nconst OTPInput = /*#__PURE__*/memo(OTPInputComponent);\nexport default OTPInput;","map":null,"metadata":{},"sourceType":"module"}